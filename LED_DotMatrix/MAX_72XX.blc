import ut "utils"

module exposes init, append_msg, clear_display, cycle_through_digits, LEN

@[CFunction (binding = "write_data_to_reg($1, $2)", header = "env.h")]
extern function write_data_to_reg (reg : bits8, state : bits8)

@[CFunction (binding = "DEBUG($1)", header = "env.h")]
extern function DEBUG (x : int32)

const LEN: nat8 = 8
const NUM_DIGITS : bits8 = 10

struct Display
  var current_state : [8]bits8 // state of each row (0: LED off, 1: LED on)
end

struct Offset
  var x : bits8
  var y : bits8
end

// digits drawn with the matrix2bytes-tool
param digits_large: [NUM_DIGITS][LEN] bits8 = {
  {0x18, 0x24, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18}, // 0
  {0x18, 0x28, 0x48, 0x8, 0x8, 0x8, 0x8, 0x3e},     // 1
  {0x1c, 0x24, 0x44, 0x8, 0x10, 0x20, 0x7c, 0x0},   // 2
  {0x38, 0x44, 0x4, 0x3c, 0x38, 0x4, 0x44, 0x38},   // 3
  {0x48, 0x48, 0x48, 0x48, 0x78, 0x8, 0x8, 0x8},    // 4
  {0x3e, 0x20, 0x20, 0x3e, 0x3e, 0x2, 0x2, 0x3e},   // 5
  {0x4, 0x8, 0x10, 0x20, 0x38, 0x44, 0x42, 0x3c},   // 6
  {0x7f, 0x2, 0x4, 0x3e, 0x10, 0x20, 0x40, 0x80},   // 7
  {0x3c, 0x42, 0x42, 0x3c, 0x3c, 0x42, 0x42, 0x3c}, // 8
  {0x38, 0x44, 0x44, 0x38, 0x4, 0x4, 0x4, 0x38}     // 9
}

param digits_3x5: [NUM_DIGITS][LEN] bits8 = {
  {0xe0, 0xa0, 0xa0, 0xa0, 0xe0, 0x0, 0x0, 0x0}, // 0 (3x5)
  {0x40, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0}, // 1 (3x5)
  {0xe0, 0x20, 0xe0, 0x80, 0xe0, 0x0, 0x0, 0x0}, // 2 (3x5)
  {0xe0, 0x20, 0xe0, 0x20, 0xe0, 0x0, 0x0, 0x0}, // 3 (3x5)
  {0xa0, 0xa0, 0xe0, 0x20, 0x20, 0x0, 0x0, 0x0}, // 4 (3x5)
  {0xe0, 0x80, 0xe0, 0x20, 0xe0, 0x0, 0x0, 0x0}, // 5 (3x5)
  {0xe0, 0x80, 0xe0, 0xa0, 0xe0, 0x0, 0x0, 0x0}, // 6 (3x5)
  {0xe0, 0x20, 0x20, 0x20, 0x20, 0x0, 0x0, 0x0}, // 7 (3x5)
  {0xe0, 0xa0, 0xe0, 0xa0, 0xe0, 0x0, 0x0, 0x0}, // 8 (3x5)
  {0xe0, 0xa0, 0xe0, 0x20, 0xe0, 0x0, 0x0, 0x0} // 9 (3x5)
}

function init () returns Display
  return {current_state = {0,0,0,0, 0,0,0,0}}
end

function write_row (d : Display, row : bits8, state : bits8) returns Display
  var display = d
  if 0 <= row and row < 8 then
    display.current_state[row] = state
  end
  return display
end

function append_msg (d : Display, msg : [LEN]bits8, offset : Offset) returns Display
  var display = d
  var row : bits8 = 0

  if    (0 <= offset.x and offset.x < 8) 
    and (0 <= offset.y and offset.y < 8) then
    var msg_to_write = display.current_state
    row = offset.y
    repeat
      msg_to_write[row] = msg_to_write[row] | (msg[row] >> offset.x)
      row = row + 1
    until row == 8 end

    row=0
    repeat
      display = write_row(display, row, msg_to_write[row])
      row = row + 1
    until row == 8 end
  end
  return display
end

function clear_display (d : Display) returns Display
  var cleared = d
  var row : bits8 = 0
  repeat
    cleared.current_state[row] = 0x00
    row = row + 1
  until row == 8 end
  return cleared
end

function draw_display(d : Display)
  var row : bits8 = 0
  repeat
    write_data_to_reg(row+1, d.current_state[row])
    row = row + 1
  until row == 8 end
end

function set_intensity(intensity : bits8)
  write_data_to_reg(0x0A, intensity)
end

function append_digit(d:Display, digit : bits8, offset : Offset) returns Display
  var display = d
  if (0 <= digit and digit <= 9) then
    display = append_msg(d, digits_3x5[digit], offset)
  end
  return display
end

function write_number (d : Display, num : bits8) returns Display
  var display = d
  if num < 100 then
    display = append_digit(d, num/10, {x=0, y=0} )
    DEBUG(num/10 as int32)
    display = append_digit(display, num%10, {x=4, y=0} )
    DEBUG((num %10) as int32 )
  end
  return display
end

activity cycle_through_digits ()
  var i : bits8 = 10
  var d : Display = init()
  set_intensity(0)
  draw_display(d)
  repeat
    d = write_number(d, i)
    draw_display(d)
    i = i + 1
    i = i % 100
    run ut.delay(1000)
    d = clear_display(d)
    draw_display(d)
    run ut.delay(1000)
  end
end

